// Do not edit this file; automatically generated by build.py.
'use strict';


Blockly.cpp = new Blockly.Generator("cpp");
Blockly.cpp.addReservedWords("assert,break,case,catch,class,const,continue,default,do,else,enum,extends,false,final,finally,for,if,in,is,new,null,rethrow,return,super,switch,this,throw,true,try,var,void,while,with,print,identityHashCode,identical,BidirectionalIterator,Comparable,double,Function,int,Invocation,Iterable,Iterator,List,Map,Match,num,Pattern,RegExp,Set,StackTrace,String,StringSink,Type,bool,DateTime,Deprecated,Duration,Expando,Null,Object,RuneIterator,Runes,Stopwatch,StringBuffer,Symbol,Uri,Comparator,AbstractClassInstantiationError,ArgumentError,AssertionError,CastError,ConcurrentModificationError,CyclicInitializationError,Error,Exception,FallThroughError,FormatException,IntegerDivisionByZeroException,NoSuchMethodError,NullThrownError,OutOfMemoryError,RangeError,StackOverflowError,StateError,TypeError,UnimplementedError,UnsupportedError");
Blockly.cpp.ORDER_ATOMIC = 0;
Blockly.cpp.ORDER_UNARY_POSTFIX = 1;
Blockly.cpp.ORDER_UNARY_PREFIX = 2;
Blockly.cpp.ORDER_MULTIPLICATIVE = 3;
Blockly.cpp.ORDER_ADDITIVE = 4;
Blockly.cpp.ORDER_SHIFT = 5;
Blockly.cpp.ORDER_BITWISE_AND = 6;
Blockly.cpp.ORDER_BITWISE_XOR = 7;
Blockly.cpp.ORDER_BITWISE_OR = 8;
Blockly.cpp.ORDER_RELATIONAL = 9;
Blockly.cpp.ORDER_EQUALITY = 10;
Blockly.cpp.ORDER_LOGICAL_AND = 11;
Blockly.cpp.ORDER_LOGICAL_OR = 12;
Blockly.cpp.ORDER_IF_NULL = 13;
Blockly.cpp.ORDER_CONDITIONAL = 14;
Blockly.cpp.ORDER_CASCADE = 15;
Blockly.cpp.ORDER_ASSIGNMENT = 16;
Blockly.cpp.ORDER_NONE = 99;
Blockly.cpp.init = function (a) {
    Blockly.cpp.definitions_ = Object.create(null);
    Blockly.cpp.functionNames_ = Object.create(null);
    Blockly.cpp.nameDB_ ? Blockly.cpp.nameDB_.reset() : Blockly.cpp.nameDB_ = new Blockly.Names(Blockly.cpp.RESERVED_WORDS_);
    Blockly.cpp.nameDB_.setVariableMap(a.getVariableMap());
    for (var b = [], c = Blockly.Variables.allDeveloperVariables(a), d = 0; d < c.length; d++) b.push(Blockly.cpp.nameDB_.getName(c[d], Blockly.Names.DEVELOPER_VARIABLE_TYPE));
    a = Blockly.Variables.allUsedVarModels(a);

    var var_number = [];
    var var_string = [];
    var var_double = [];

    Blockly.cpp.LOG_VAR = a;

    for (d = 0; d < a.length; d++) {
        if (a[d].type === "String")
            var_string.push(Blockly.cpp.nameDB_.getName(a[d].getId(), Blockly.Variables.NAME_TYPE));
        if (a[d].type === "Number" || a[d].type === "")
            var_number.push(Blockly.cpp.nameDB_.getName(a[d].getId(), Blockly.Variables.NAME_TYPE));
        if (a[d].type === "Double")
            var_double.push(Blockly.cpp.nameDB_.getName(a[d].getId(), Blockly.Variables.NAME_TYPE));
        b.push(Blockly.cpp.nameDB_.getName(a[d].getId(), Blockly.Variables.NAME_TYPE));
    }

    if (var_number.length > 0) Blockly.cpp.definitions_.variables_number = "int " + var_number.join(", ") + ";";
    if (var_string.length > 0) Blockly.cpp.definitions_.variables_colour = "string " + var_string.join(", ") + ";";
    if (var_double.length > 0) Blockly.cpp.definitions_.variables_double = "double " + var_double.join(", ") + ";";

    //b.length && (Blockly.cpp.definitions_.variables = "var " + b.join(", ") + ";")
};
Blockly.cpp.finish = function (a) {
    if (localStorage.getItem("rC:intmain") == 'true') {
        a && (a = Blockly.cpp.prefixLines(a, Blockly.cpp.INDENT));
        a = "int main() {\n" + a + "}";
        var b = [], c = [], d, sep = "";
        for (d in Blockly.cpp.definitions_) {
            var e = Blockly.cpp.definitions_[d];
            if (e.startsWith("#include"))
                c.push(e);
            else
                b.push(e);
            //e.match(/^import\s/) ? c.push(e): b.push(e)
        }
        delete Blockly.cpp.definitions_;
        delete Blockly.cpp.functionNames_;
        Blockly.cpp.nameDB_.reset();
        if (c.length != 0) sep = "\n";
        return c.join("\n") + sep + "#include<iostream>\nusing namespace std;\n" + (b.join("\n") + "\n") + a
    }
    else {
        var b = [], c = [], d, sep = "";
        for (d in Blockly.cpp.definitions_) {
            var e = Blockly.cpp.definitions_[d];
            if (e.startsWith("#include"))
                c.push(e);
            else
                b.push(e);
            //e.match(/^import\s/) ? c.push(e): b.push(e)
        }
        delete Blockly.cpp.definitions_;
        delete Blockly.cpp.functionNames_;
        Blockly.cpp.nameDB_.reset();
        if (c.length != 0) sep = "\n";
        return c.join("\n") + sep + a + (b.join("\n") + "\n")
    }
};
Blockly.cpp.scrubNakedValue = function (a) {
    return a + ";\n"
};
Blockly.cpp.quote_ = function (a) {
    a = a.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n").replace(/\$/g, "\\$").replace(/'/g, "\\'");
    return '"' + a + '"'
};
Blockly.cpp.scrub_ = function (a, b, c) {
    var d = ""; if (!a.outputConnection || !a.outputConnection.targetConnection) { var e = a.getCommentText(); e && (e = Blockly.utils.string.wrap(e, this.COMMENT_WRAP - 3), d = a.getProcedureDef ? d + this.prefixLines(e + "\n", "/// ") : d + this.prefixLines(e + "\n", "// ")); for (var f = 0; f < a.inputList.length; f++)a.inputList[f].type == Blockly.inputTypes.VALUE && (e = a.inputList[f].connection.targetBlock()) && (e = this.allNestedComments(e)) && (d += this.prefixLines(e, "// ")) } a = a.nextConnection && a.nextConnection.targetBlock();
    c = c ? "" : this.blockToCode(a); return d + b + c
};
Blockly.cpp.getAdjusted = function (a, b, c, d, e) {
    c = c || 0;
    e = e || Blockly.cpp.ORDER_NONE;
    a.workspace.options.oneBasedIndex && c--;
    var f = a.workspace.options.oneBasedIndex ? "1" : "0";
    a = c ? Blockly.cpp.valueToCode(a, b, Blockly.cpp.ORDER_ADDITIVE) || f : d ? Blockly.cpp.valueToCode(a, b, Blockly.cpp.ORDER_UNARY_PREFIX) || f : Blockly.cpp.valueToCode(a, b, e) || f;
    if (Blockly.isNumber(a)) a = parseInt(a, 10) + c, d && (a = -a); else {
        if (0 < c) {
            a = a + " + " + c;
            var g = Blockly.cpp.ORDER_ADDITIVE
        } else 0 > c && (a = a + " - " + -c, g = Blockly.cpp.ORDER_ADDITIVE);
        d && (a = c ? "-(" + a + ")" : "-" + a, g = Blockly.cpp.ORDER_UNARY_PREFIX);
        g = Math.floor(g);
        e = Math.floor(e);
        g && e >= g && (a = "(" + a + ")")
    }
    return a
};
Blockly.cpp.colour = {};
Blockly.cpp.addReservedWords("Math");
Blockly.cpp.colour_picker = function (a) {
    return ["'" + a.getFieldValue("COLOUR") + "'", Blockly.cpp.ORDER_ATOMIC]
};
Blockly.cpp.colour_random = function (a) {
    Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
    return [Blockly.cpp.provideFunction_("colour_random", ["String " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "() {", "  String hex = '0123456789abcdef';", "  var rnd = new Math.Random();", "  return '#${hex[rnd.nextInt(16)]}${hex[rnd.nextInt(16)]}'", "      '${hex[rnd.nextInt(16)]}${hex[rnd.nextInt(16)]}'", "      '${hex[rnd.nextInt(16)]}${hex[rnd.nextInt(16)]}';", "}"]) + "()", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.colour_rgb = function (a) {
    var b = Blockly.cpp.valueToCode(a, "RED", Blockly.cpp.ORDER_NONE) || 0,
        c = Blockly.cpp.valueToCode(a, "GREEN", Blockly.cpp.ORDER_NONE) || 0;
    a = Blockly.cpp.valueToCode(a, "BLUE", Blockly.cpp.ORDER_NONE) || 0;
    Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
    return [Blockly.cpp.provideFunction_("colour_rgb", ["String " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(num r, num g, num b) {", "  num rn = (Math.max(Math.min(r, 100), 0) * 2.55).round();", "  String rs = rn.toInt().toRadixString(16);",
        "  rs = '0$rs';", "  rs = rs.substring(rs.length - 2);", "  num gn = (Math.max(Math.min(g, 100), 0) * 2.55).round();", "  String gs = gn.toInt().toRadixString(16);", "  gs = '0$gs';", "  gs = gs.substring(gs.length - 2);", "  num bn = (Math.max(Math.min(b, 100), 0) * 2.55).round();", "  String bs = bn.toInt().toRadixString(16);", "  bs = '0$bs';", "  bs = bs.substring(bs.length - 2);", "  return '#$rs$gs$bs';", "}"]) + "(" + b + ", " + c + ", " + a + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.colour_blend = function (a) {
    var b = Blockly.cpp.valueToCode(a, "COLOUR1", Blockly.cpp.ORDER_NONE) || "'#000000'",
        c = Blockly.cpp.valueToCode(a, "COLOUR2", Blockly.cpp.ORDER_NONE) || "'#000000'";
    a = Blockly.cpp.valueToCode(a, "RATIO", Blockly.cpp.ORDER_NONE) || .5;
    Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
    return [Blockly.cpp.provideFunction_("colour_blend", ["String " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(String c1, String c2, num ratio) {", "  ratio = Math.max(Math.min(ratio, 1), 0);",
        "  int r1 = int.parse('0x${c1.substring(1, 3)}');", "  int g1 = int.parse('0x${c1.substring(3, 5)}');", "  int b1 = int.parse('0x${c1.substring(5, 7)}');", "  int r2 = int.parse('0x${c2.substring(1, 3)}');", "  int g2 = int.parse('0x${c2.substring(3, 5)}');", "  int b2 = int.parse('0x${c2.substring(5, 7)}');", "  num rn = (r1 * (1 - ratio) + r2 * ratio).round();", "  String rs = rn.toInt().toRadixString(16);", "  num gn = (g1 * (1 - ratio) + g2 * ratio).round();", "  String gs = gn.toInt().toRadixString(16);",
        "  num bn = (b1 * (1 - ratio) + b2 * ratio).round();", "  String bs = bn.toInt().toRadixString(16);", "  rs = '0$rs';", "  rs = rs.substring(rs.length - 2);", "  gs = '0$gs';", "  gs = gs.substring(gs.length - 2);", "  bs = '0$bs';", "  bs = bs.substring(bs.length - 2);", "  return '#$rs$gs$bs';", "}"]) + "(" + b + ", " + c + ", " + a + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.lists = {};
Blockly.cpp.addReservedWords("Math");
Blockly.cpp.lists_create_empty = function (a) {
    return ["[]", Blockly.cpp.ORDER_ATOMIC]
};
Blockly.cpp.lists_create_with = function (a) {
    for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) b[c] = Blockly.cpp.valueToCode(a, "ADD" + c, Blockly.cpp.ORDER_NONE) || "null";
    return ["[" + b.join(", ") + "]", Blockly.cpp.ORDER_ATOMIC]
};
Blockly.cpp.lists_repeat = function (a) {
    var b = Blockly.cpp.valueToCode(a, "ITEM", Blockly.cpp.ORDER_NONE) || "null";
    return ["new List.filled(" + (Blockly.cpp.valueToCode(a, "NUM", Blockly.cpp.ORDER_NONE) || "0") + ", " + b + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.lists_length = function (a) {
    return [(Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_UNARY_POSTFIX) || "[]") + ".length", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.lists_isEmpty = function (a) {
    return [(Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_UNARY_POSTFIX) || "[]") + ".isEmpty", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.lists_indexOf = function (a) {
    var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
        c = Blockly.cpp.valueToCode(a, "FIND", Blockly.cpp.ORDER_NONE) || "''";
    b = (Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_UNARY_POSTFIX) || "[]") + "." + b + "(" + c + ")";
    return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.cpp.ORDER_ADDITIVE] : [b, Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.lists_getIndex = function (a) {
    function b() {
        var a = Blockly.cpp.nameDB_.getDistinctName("tmp_list", Blockly.Variables.NAME_TYPE),
            b = "List " + a + " = " + e + ";\n";
        e = a;
        return b
    }

    var c = a.getFieldValue("MODE") || "GET", d = a.getFieldValue("WHERE") || "FROM_START",
        e = Blockly.cpp.valueToCode(a, "VALUE", "RANDOM" == d || "FROM_END" == d ? Blockly.cpp.ORDER_NONE : Blockly.cpp.ORDER_UNARY_POSTFIX) || "[]";
    if (("RANDOM" != d || "REMOVE" != c) && "FROM_END" != d || e.match(/^\w+$/)) switch (d) {
        case "FIRST":
            if ("GET" == c) return [e + ".first",
            Blockly.cpp.ORDER_UNARY_POSTFIX];
            if ("GET_REMOVE" == c) return [e + ".removeAt(0)", Blockly.cpp.ORDER_UNARY_POSTFIX];
            if ("REMOVE" == c) return e + ".removeAt(0);\n";
            break;
        case "LAST":
            if ("GET" == c) return [e + ".last", Blockly.cpp.ORDER_UNARY_POSTFIX];
            if ("GET_REMOVE" == c) return [e + ".removeLast()", Blockly.cpp.ORDER_UNARY_POSTFIX];
            if ("REMOVE" == c) return e + ".removeLast();\n";
            break;
        case "FROM_START":
            d = Blockly.cpp.getAdjusted(a, "AT");
            if ("GET" == c) return [e + "[" + d + "]", Blockly.cpp.ORDER_UNARY_POSTFIX];
            if ("GET_REMOVE" == c) return [e +
                ".removeAt(" + d + ")", Blockly.cpp.ORDER_UNARY_POSTFIX];
            if ("REMOVE" == c) return e + ".removeAt(" + d + ");\n";
            break;
        case "FROM_END":
            d = Blockly.cpp.getAdjusted(a, "AT", 1, !1, Blockly.cpp.ORDER_ADDITIVE);
            if ("GET" == c) return [e + "[" + e + ".length - " + d + "]", Blockly.cpp.ORDER_UNARY_POSTFIX];
            if ("GET_REMOVE" == c || "REMOVE" == c) {
                a = e + ".removeAt(" + e + ".length - " + d + ")";
                if ("GET_REMOVE" == c) return [a, Blockly.cpp.ORDER_UNARY_POSTFIX];
                if ("REMOVE" == c) return a + ";\n"
            }
            break;
        case "RANDOM":
            Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
            if ("REMOVE" == c) return c = Blockly.cpp.nameDB_.getDistinctName("tmp_x", Blockly.Variables.NAME_TYPE), "int " + c + " = new Math.Random().nextInt(" + e + ".length);\n" + (e + ".removeAt(" + c + ");\n");
            if ("GET" == c) return c = Blockly.cpp.provideFunction_("lists_get_random_item", ["dynamic " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List my_list) {", "  int x = new Math.Random().nextInt(my_list.length);", "  return my_list[x];", "}"]), [c + "(" + e + ")", Blockly.cpp.ORDER_UNARY_POSTFIX];
            if ("GET_REMOVE" == c) return c = Blockly.cpp.provideFunction_("lists_remove_random_item",
                ["dynamic " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List my_list) {", "  int x = new Math.Random().nextInt(my_list.length);", "  return my_list.removeAt(x);", "}"]), [c + "(" + e + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
    } else {
        if ("RANDOM" == d) return Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;", a = b(), c = Blockly.cpp.nameDB_.getDistinctName("tmp_x", Blockly.Variables.NAME_TYPE), a + ("int " + c + " = new Math.Random().nextInt(" + e + ".length);\n") + (e + ".removeAt(" + c + ");\n");
        if ("REMOVE" == c) return d =
            Blockly.cpp.getAdjusted(a, "AT", 1, !1, Blockly.cpp.ORDER_ADDITIVE), a = b(), a += e + ".removeAt(" + e + ".length - " + d + ");\n";
        if ("GET" == c) return d = Blockly.cpp.getAdjusted(a, "AT", 1), c = Blockly.cpp.provideFunction_("lists_get_from_end", ["dynamic " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List my_list, num x) {", "  x = my_list.length - x;", "  return my_list[x];", "}"]), [c + "(" + e + ", " + d + ")", Blockly.cpp.ORDER_UNARY_POSTFIX];
        if ("GET_REMOVE" == c) return d = Blockly.cpp.getAdjusted(a, "AT", 1), c = Blockly.cpp.provideFunction_("lists_remove_from_end",
            ["dynamic " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List my_list, num x) {", "  x = my_list.length - x;", "  return my_list.removeAt(x);", "}"]), [c + "(" + e + ", " + d + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
    }
    throw Error("Unhandled combination (lists_getIndex).");
};
Blockly.cpp.lists_setIndex = function (a) {
    function b() {
        if (e.match(/^\w+$/)) return "";
        var a = Blockly.cpp.nameDB_.getDistinctName("tmp_list", Blockly.Variables.NAME_TYPE),
            b = "List " + a + " = " + e + ";\n";
        e = a;
        return b
    }

    var c = a.getFieldValue("MODE") || "GET", d = a.getFieldValue("WHERE") || "FROM_START",
        e = Blockly.cpp.valueToCode(a, "LIST", Blockly.cpp.ORDER_UNARY_POSTFIX) || "[]",
        f = Blockly.cpp.valueToCode(a, "TO", Blockly.cpp.ORDER_ASSIGNMENT) || "null";
    switch (d) {
        case "FIRST":
            if ("SET" == c) return e + "[0] = " + f + ";\n";
            if ("INSERT" ==
                c) return e + ".insert(0, " + f + ");\n";
            break;
        case "LAST":
            if ("SET" == c) return a = b(), a + (e + "[" + e + ".length - 1] = " + f + ";\n");
            if ("INSERT" == c) return e + ".add(" + f + ");\n";
            break;
        case "FROM_START":
            d = Blockly.cpp.getAdjusted(a, "AT");
            if ("SET" == c) return e + "[" + d + "] = " + f + ";\n";
            if ("INSERT" == c) return e + ".insert(" + d + ", " + f + ");\n";
            break;
        case "FROM_END":
            d = Blockly.cpp.getAdjusted(a, "AT", 1, !1, Blockly.cpp.ORDER_ADDITIVE);
            a = b();
            if ("SET" == c) return a + (e + "[" + e + ".length - " + d + "] = " + f + ";\n");
            if ("INSERT" == c) return a + (e + ".insert(" +
                e + ".length - " + d + ", " + f + ");\n");
            break;
        case "RANDOM":
            Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
            a = b();
            d = Blockly.cpp.nameDB_.getDistinctName("tmp_x", Blockly.Variables.NAME_TYPE);
            a += "int " + d + " = new Math.Random().nextInt(" + e + ".length);\n";
            if ("SET" == c) return a + (e + "[" + d + "] = " + f + ";\n");
            if ("INSERT" == c) return a + (e + ".insert(" + d + ", " + f + ");\n")
    }
    throw Error("Unhandled combination (lists_setIndex).");
};
Blockly.cpp.lists_getSublist = function (a) {
    var b = Blockly.cpp.valueToCode(a, "LIST", Blockly.cpp.ORDER_UNARY_POSTFIX) || "[]",
        c = a.getFieldValue("WHERE1"), d = a.getFieldValue("WHERE2");
    if (b.match(/^\w+$/) || "FROM_END" != c && "FROM_START" == d) {
        switch (c) {
            case "FROM_START":
                var e = Blockly.cpp.getAdjusted(a, "AT1");
                break;
            case "FROM_END":
                e = Blockly.cpp.getAdjusted(a, "AT1", 1, !1, Blockly.cpp.ORDER_ADDITIVE);
                e = b + ".length - " + e;
                break;
            case "FIRST":
                e = "0";
                break;
            default:
                throw Error("Unhandled option (lists_getSublist).");
        }
        switch (d) {
            case "FROM_START":
                var f =
                    Blockly.cpp.getAdjusted(a, "AT2", 1);
                break;
            case "FROM_END":
                f = Blockly.cpp.getAdjusted(a, "AT2", 0, !1, Blockly.cpp.ORDER_ADDITIVE);
                f = b + ".length - " + f;
                break;
            case "LAST":
                break;
            default:
                throw Error("Unhandled option (lists_getSublist).");
        }
        a = "LAST" == d ? b + ".sublist(" + e + ")" : b + ".sublist(" + e + ", " + f + ")"
    } else e = Blockly.cpp.getAdjusted(a, "AT1"), f = Blockly.cpp.getAdjusted(a, "AT2"), a = Blockly.cpp.provideFunction_("lists_get_sublist", ["List " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(list, where1, at1, where2, at2) {",
        "  int getAt(where, at) {", "    if (where == 'FROM_END') {", "      at = list.length - 1 - at;", "    } else if (where == 'FIRST') {", "      at = 0;", "    } else if (where == 'LAST') {", "      at = list.length - 1;", "    } else if (where != 'FROM_START') {", "      throw 'Unhandled option (lists_getSublist).';", "    }", "    return at;", "  }", "  at1 = getAt(where1, at1);", "  at2 = getAt(where2, at2) + 1;", "  return list.sublist(at1, at2);", "}"]) + "(" + b + ", '" + c + "', " + e + ", '" + d + "', " + f + ")";
    return [a, Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.lists_sort = function (a) {
    var b = Blockly.cpp.valueToCode(a, "LIST", Blockly.cpp.ORDER_NONE) || "[]",
        c = "1" === a.getFieldValue("DIRECTION") ? 1 : -1;
    a = a.getFieldValue("TYPE");
    return [Blockly.cpp.provideFunction_("lists_sort", ["List " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(list, type, direction) {", "  var compareFuncs = {", '    "NUMERIC": (a, b) => direction * a.compareTo(b),', '    "TEXT": (a, b) => direction * a.toString().compareTo(b.toString()),', '    "IGNORE_CASE": ', "       (a, b) => direction * ",
        "      a.toString().toLowerCase().compareTo(b.toString().toLowerCase())", "  };", "  list = new List.from(list);", "  var compare = compareFuncs[type];", "  list.sort(compare);", "  return list;", "}"]) + "(" + b + ', "' + a + '", ' + c + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.lists_split = function (a) {
    var b = Blockly.cpp.valueToCode(a, "INPUT", Blockly.cpp.ORDER_UNARY_POSTFIX),
        c = Blockly.cpp.valueToCode(a, "DELIM", Blockly.cpp.ORDER_NONE) || "''";
    a = a.getFieldValue("MODE");
    if ("SPLIT" == a) b || (b = "''"), a = "split"; else if ("JOIN" == a) b || (b = "[]"), a = "join"; else throw Error("Unknown mode: " + a);
    return [b + "." + a + "(" + c + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.lists_reverse = function (a) {
    return ["new List.from(" + (Blockly.cpp.valueToCode(a, "LIST", Blockly.cpp.ORDER_NONE) || "[]") + ".reversed)", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.logic = {};
Blockly.cpp.controls_if = function (a) {
    var b = 0, c = "";
    do {
        var d = Blockly.cpp.valueToCode(a, "IF" + b, Blockly.cpp.ORDER_NONE) || "false";
        var e = Blockly.cpp.statementToCode(a, "DO" + b);
        c += (0 < b ? "else " : "") + "if (" + d + ") {\n" + e + "}";
        ++b
    } while (a.getInput("IF" + b));
    a.getInput("ELSE") && (e = Blockly.cpp.statementToCode(a, "ELSE"), c += " else {\n" + e + "}");
    return c + "\n"
};
Blockly.cpp.controls_ifelse = Blockly.cpp.controls_if;
Blockly.cpp.logic_compare = function (a) {
    var b = { EQ: "==", NEQ: "!=", LT: "<", LTE: "<=", GT: ">", GTE: ">=" }[a.getFieldValue("OP")],
        c = "==" == b || "!=" == b ? Blockly.cpp.ORDER_EQUALITY : Blockly.cpp.ORDER_RELATIONAL,
        d = Blockly.cpp.valueToCode(a, "A", c) || "0";
    a = Blockly.cpp.valueToCode(a, "B", c) || "0";
    return [d + " " + b + " " + a, c]
};
Blockly.cpp.logic_operation = function (a) {
    var b = "AND" == a.getFieldValue("OP") ? "&&" : "||",
        c = "&&" == b ? Blockly.cpp.ORDER_LOGICAL_AND : Blockly.cpp.ORDER_LOGICAL_OR,
        d = Blockly.cpp.valueToCode(a, "A", c);
    a = Blockly.cpp.valueToCode(a, "B", c);
    if (d || a) {
        var e = "&&" == b ? "true" : "false";
        d || (d = e);
        a || (a = e)
    } else a = d = "false";
    return [d + " " + b + " " + a, c]
};
Blockly.cpp.logic_negate = function (a) {
    var b = Blockly.cpp.ORDER_UNARY_PREFIX;
    return ["!" + (Blockly.cpp.valueToCode(a, "BOOL", b) || "true"), b]
};
Blockly.cpp.logic_boolean = function (a) {
    return ["TRUE" == a.getFieldValue("BOOL") ? "true" : "false", Blockly.cpp.ORDER_ATOMIC]
};
Blockly.cpp.logic_null = function (a) {
    return ["null", Blockly.cpp.ORDER_ATOMIC]
};
Blockly.cpp.logic_ternary = function (a) {
    var b = Blockly.cpp.valueToCode(a, "IF", Blockly.cpp.ORDER_CONDITIONAL) || "false",
        c = Blockly.cpp.valueToCode(a, "THEN", Blockly.cpp.ORDER_CONDITIONAL) || "null";
    a = Blockly.cpp.valueToCode(a, "ELSE", Blockly.cpp.ORDER_CONDITIONAL) || "null";
    return [b + " ? " + c + " : " + a, Blockly.cpp.ORDER_CONDITIONAL]
};
Blockly.cpp.loops = {};
Blockly.cpp.controls_repeat_ext = function (a) {
    var b = a.getField("TIMES") ? String(Number(a.getFieldValue("TIMES"))) : Blockly.cpp.valueToCode(a, "TIMES", Blockly.cpp.ORDER_ASSIGNMENT) || "0",
        c = Blockly.cpp.statementToCode(a, "DO");
    c = Blockly.cpp.addLoopTrap(c, a.id);
    a = "";
    var d = Blockly.cpp.nameDB_.getDistinctName("count", Blockly.Variables.NAME_TYPE), e = b;
    b.match(/^\w+$/) || Blockly.isNumber(b) || (e = Blockly.cpp.nameDB_.getDistinctName("repeat_end", Blockly.Variables.NAME_TYPE), a += "var " + e + " = " + b + ";\n");
    return a + ("for (int " + d + " = 0; " + d + " < " + e + "; " + d + "++) {\n" + c + "}\n")
};
Blockly.cpp.controls_repeat = Blockly.cpp.controls_repeat_ext;
Blockly.cpp.controls_whileUntil = function (a) {
    var b = "UNTIL" == a.getFieldValue("MODE"),
        c = Blockly.cpp.valueToCode(a, "BOOL", b ? Blockly.cpp.ORDER_UNARY_PREFIX : Blockly.cpp.ORDER_NONE) || "false",
        d = Blockly.cpp.statementToCode(a, "DO");
    d = Blockly.cpp.addLoopTrap(d, a.id);
    b && (c = "!" + c);
    return "while (" + c + ") {\n" + d + "}\n"
};
Blockly.cpp.controls_for = function (a) {
    var b = Blockly.cpp.nameDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE),
        c = Blockly.cpp.valueToCode(a, "FROM", Blockly.cpp.ORDER_ASSIGNMENT) || "0",
        d = Blockly.cpp.valueToCode(a, "TO", Blockly.cpp.ORDER_ASSIGNMENT) || "0",
        e = Blockly.cpp.valueToCode(a, "BY", Blockly.cpp.ORDER_ASSIGNMENT) || "1",
        f = Blockly.cpp.statementToCode(a, "DO");
    f = Blockly.cpp.addLoopTrap(f, a.id);
    if (Blockly.isNumber(c) && Blockly.isNumber(d) && Blockly.isNumber(e)) {
        var g = parseFloat(c) <=
            parseFloat(d);
        a = "for (" + b + " = " + c + "; " + b + (g ? " <= " : " >= ") + d + "; " + b;
        b = Math.abs(parseFloat(e));
        a = (1 == b ? a + (g ? "++" : "--") : a + ((g ? " += " : " -= ") + b)) + (") {\n" + f + "}\n")
    } else a = "", g = c, c.match(/^\w+$/) || Blockly.isNumber(c) || (g = Blockly.cpp.nameDB_.getDistinctName(b + "_start", Blockly.Variables.NAME_TYPE), a += "var " + g + " = " + c + ";\n"), c = d, d.match(/^\w+$/) || Blockly.isNumber(d) || (c = Blockly.cpp.nameDB_.getDistinctName(b + "_end", Blockly.Variables.NAME_TYPE), a += "var " + c + " = " + d + ";\n"), d = Blockly.cpp.nameDB_.getDistinctName(b +
        "_inc", Blockly.Variables.NAME_TYPE), a += "num " + d + " = ", a = Blockly.isNumber(e) ? a + (Math.abs(e) + ";\n") : a + ("(" + e + ").abs();\n"), a = a + ("if (" + g + " > " + c + ") {\n") + (Blockly.cpp.INDENT + d + " = -" + d + ";\n"), a += "}\n", a += "for (" + b + " = " + g + "; " + d + " >= 0 ? " + b + " <= " + c + " : " + b + " >= " + c + "; " + b + " += " + d + ") {\n" + f + "}\n";
    return a
};
Blockly.cpp.controls_forEach = function (a) {
    var b = Blockly.cpp.nameDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE),
        c = Blockly.cpp.valueToCode(a, "LIST", Blockly.cpp.ORDER_ASSIGNMENT) || "[]",
        d = Blockly.cpp.statementToCode(a, "DO");
    d = Blockly.cpp.addLoopTrap(d, a.id);
    return "for (var " + b + " in " + c + ") {\n" + d + "}\n"
};
Blockly.cpp.controls_flow_statements = function (a) {
    switch (a.getFieldValue("FLOW")) {
        case "BREAK":
            return "break;\n";
        case "CONTINUE":
            return "continue;\n"
    }
    throw Error("Unknown flow statement.");
};
Blockly.cpp.math = {};
Blockly.cpp.addReservedWords("Math");
Blockly.cpp.math_number = function (a) {
    a = parseFloat(a.getFieldValue("NUM"));
    if (Infinity == a) {
        a = "double.INFINITY";
        var b = Blockly.cpp.ORDER_UNARY_POSTFIX
    } else -Infinity == a ? (a = "-double.INFINITY", b = Blockly.cpp.ORDER_UNARY_PREFIX) : b = 0 > a ? Blockly.cpp.ORDER_UNARY_PREFIX : Blockly.cpp.ORDER_ATOMIC;
    return [a, b]
};
Blockly.cpp.float_number = function (a) {
    a = parseFloat(a.getFieldValue("NUM"));
    if (Infinity == a) {
        a = "double.INFINITY";
        var b = Blockly.cpp.ORDER_UNARY_POSTFIX
    } else -Infinity == a ? (a = "-double.INFINITY", b = Blockly.cpp.ORDER_UNARY_PREFIX) : b = 0 > a ? Blockly.cpp.ORDER_UNARY_PREFIX : Blockly.cpp.ORDER_ATOMIC;
    return [a, b]
};
Blockly.cpp.math_arithmetic = function (a) {
    var b = {
        ADD: [" + ", Blockly.cpp.ORDER_ADDITIVE],
        MINUS: [" - ", Blockly.cpp.ORDER_ADDITIVE],
        MULTIPLY: [" * ", Blockly.cpp.ORDER_MULTIPLICATIVE],
        DIVIDE: [" / ", Blockly.cpp.ORDER_MULTIPLICATIVE],
        POWER: [null, Blockly.cpp.ORDER_NONE]
    }[a.getFieldValue("OP")], c = b[0];
    b = b[1];
    var d = Blockly.cpp.valueToCode(a, "A", b) || "0";
    a = Blockly.cpp.valueToCode(a, "B", b) || "0";
    return c ? [d + c + a, b] : (Blockly.cpp.definitions_.import_cpp_math = "#include<cmath>", ["pow(" + d + ", " +
        a + ")", Blockly.cpp.ORDER_UNARY_POSTFIX])
};
Blockly.cpp.math_single = function (a) {
    var b = a.getFieldValue("OP");
    if ("NEG" == b) return a = Blockly.cpp.valueToCode(a, "NUM", Blockly.cpp.ORDER_UNARY_PREFIX) || "0", "-" == a[0] && (a = " " + a), ["-" + a, Blockly.cpp.ORDER_UNARY_PREFIX];
    Blockly.cpp.definitions_.import_cpp_math = "#include<cmath>";
    a = "ABS" == b || "ROUND" == b.substring(0, 5) ? Blockly.cpp.valueToCode(a, "NUM", Blockly.cpp.ORDER_UNARY_POSTFIX) || "0" : "SIN" == b || "COS" == b || "TAN" == b ? Blockly.cpp.valueToCode(a, "NUM", Blockly.cpp.ORDER_MULTIPLICATIVE) || "0" :
        Blockly.cpp.valueToCode(a, "NUM", Blockly.cpp.ORDER_NONE) || "0";
    switch (b) {
        case "ABS":
            var c = "abs(" + a + ")";
            break;
        case "ROOT":
            c = "sqrt(" + a + ")";
            break;
        case "LN":
            c = "log(" + a + ")";
            break;
        case "EXP":
            c = "exp(" + a + ")";
            break;
        case "POW10":
            c = "pow(10," + a + ")";
            break;
        case "ROUND":
            c = a + ".round()";
            break;
        case "ROUNDUP":
            c = "ceil(" + a + ")";
            break;
        case "ROUNDDOWN":
            c = "floor(" + a + ")";
            break;
        case "SIN":
            c = "sin(" + a + ")";
            break;
        case "COS":
            c = "cos(" + a + ")";
            break;
        case "TAN":
            c = "tan(" + a + ")"
    }
    if (c) return [c, Blockly.cpp.ORDER_UNARY_POSTFIX];
    switch (b) {
        case "LOG10":
            c = "log10(" + a + ")";
            break;
        case "ASIN":
            c = "asin(" + a + ")";
            break;
        case "ACOS":
            c = "acos(" + a + ")";
            break;
        case "ATAN":
            c = "atan(" + a + ")";
            break;
        default:
            throw Error("Unknown math operator: " + b);
    }
    return [c, Blockly.cpp.ORDER_MULTIPLICATIVE]
};
Blockly.cpp.math_constant = function (a) {
    var b = {
        PI: ["M_PI", Blockly.cpp.ORDER_UNARY_POSTFIX],
        E: ["M_E", Blockly.cpp.ORDER_UNARY_POSTFIX],
        GOLDEN_RATIO: ["(1 + sqrt(5)) / 2", Blockly.cpp.ORDER_MULTIPLICATIVE],
        SQRT2: ["sqrt(2)", Blockly.cpp.ORDER_UNARY_POSTFIX],
        SQRT1_2: ["sqrt(1./2)", Blockly.cpp.ORDER_UNARY_POSTFIX],
        INFINITY: ["INT_MAX", Blockly.cpp.ORDER_ATOMIC]
    };
    a = a.getFieldValue("CONSTANT");
    "INFINITY" != a && (Blockly.cpp.definitions_.import_cpp_math = "#include<cmath>");
    return b[a]
};
Blockly.cpp.math_number_property = function (a) {
    var b = Blockly.cpp.valueToCode(a, "NUMBER_TO_CHECK", Blockly.cpp.ORDER_MULTIPLICATIVE);
    if (!b) return ["false", Blockly.Python.ORDER_ATOMIC];
    var c = a.getFieldValue("PROPERTY");
    if ("PRIME" == c) return Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;", [Blockly.cpp.provideFunction_("math_isPrime", ["bool " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(n) {", "  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods", "  if (n == 2 || n == 3) {", "    return true;",
        "  }", "  // False if n is null, negative, is 1, or not whole.", "  // And false if n is divisible by 2 or 3.", "  if (n == null || n <= 1 || n % 1 != 0 || n % 2 == 0 || n % 3 == 0) {", "    return false;", "  }", "  // Check all the numbers of form 6k +/- 1, up to sqrt(n).", "  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {", "    if (n % (x - 1) == 0 || n % (x + 1) == 0) {", "      return false;", "    }", "  }", "  return true;", "}"]) + "(" + b + ")", Blockly.cpp.ORDER_UNARY_POSTFIX];
    switch (c) {
        case "EVEN":
            var d =
                b + " % 2 == 0";
            break;
        case "ODD":
            d = b + " % 2 == 1";
            break;
        case "WHOLE":
            d = b + " % 1 == 0";
            break;
        case "POSITIVE":
            d = b + " > 0";
            break;
        case "NEGATIVE":
            d = b + " < 0";
            break;
        case "DIVISIBLE_BY":
            a = Blockly.cpp.valueToCode(a, "DIVISOR", Blockly.cpp.ORDER_MULTIPLICATIVE);
            if (!a) return ["false", Blockly.Python.ORDER_ATOMIC];
            d = b + " % " + a + " == 0"
    }
    return [d, Blockly.cpp.ORDER_EQUALITY]
};
Blockly.cpp.math_change = function (a) {
    var b = Blockly.cpp.valueToCode(a, "DELTA", Blockly.cpp.ORDER_ADDITIVE) || "0";
    a = Blockly.cpp.nameDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    return a + " = (" + a + " is num ? " + a + " : 0) + " + b + ";\n"
};
Blockly.cpp.math_round = Blockly.cpp.math_single;
Blockly.cpp.math_trig = Blockly.cpp.math_single;
Blockly.cpp.math_on_list = function (a) {
    var b = a.getFieldValue("OP");
    a = Blockly.cpp.valueToCode(a, "LIST", Blockly.cpp.ORDER_NONE) || "[]";
    switch (b) {
        case "SUM":
            b = Blockly.cpp.provideFunction_("math_sum", ["num " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List myList) {", "  num sumVal = 0;", "  myList.forEach((num entry) {sumVal += entry;});", "  return sumVal;", "}"]);
            b = b + "(" + a + ")";
            break;
        case "MIN":
            Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
            b = Blockly.cpp.provideFunction_("math_min",
                ["num " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List myList) {", "  if (myList.isEmpty) return null;", "  num minVal = myList[0];", "  myList.forEach((num entry) {minVal = Math.min(minVal, entry);});", "  return minVal;", "}"]);
            b = b + "(" + a + ")";
            break;
        case "MAX":
            Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
            b = Blockly.cpp.provideFunction_("math_max", ["num " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List myList) {", "  if (myList.isEmpty) return null;", "  num maxVal = myList[0];",
                "  myList.forEach((num entry) {maxVal = Math.max(maxVal, entry);});", "  return maxVal;", "}"]);
            b = b + "(" + a + ")";
            break;
        case "AVERAGE":
            b = Blockly.cpp.provideFunction_("math_mean", ["num " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List myList) {", "  // First filter list for numbers only.", "  List localList = new List.from(myList);", "  localList.removeWhere((a) => a is! num);", "  if (localList.isEmpty) return null;", "  num sumVal = 0;", "  localList.forEach((num entry) {sumVal += entry;});", "  return sumVal / localList.length;",
                "}"]);
            b = b + "(" + a + ")";
            break;
        case "MEDIAN":
            b = Blockly.cpp.provideFunction_("math_median", ["num " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List myList) {", "  // First filter list for numbers only, then sort, then return middle value", "  // or the average of two middle values if list has an even number of elements.", "  List localList = new List.from(myList);", "  localList.removeWhere((a) => a is! num);", "  if (localList.isEmpty) return null;", "  localList.sort((a, b) => (a - b));", "  int index = localList.length ~/ 2;",
                "  if (localList.length % 2 == 1) {", "    return localList[index];", "  } else {", "    return (localList[index - 1] + localList[index]) / 2;", "  }", "}"]);
            b = b + "(" + a + ")";
            break;
        case "MODE":
            Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
            b = Blockly.cpp.provideFunction_("math_modes", ["List " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List values) {", "  List modes = [];", "  List counts = [];", "  int maxCount = 0;", "  for (int i = 0; i < values.length; i++) {", "    var value = values[i];",
                "    bool found = false;", "    int thisCount;", "    for (int j = 0; j < counts.length; j++) {", "      if (counts[j][0] == value) {", "        thisCount = ++counts[j][1];", "        found = true;", "        break;", "      }", "    }", "    if (!found) {", "      counts.add([value, 1]);", "      thisCount = 1;", "    }", "    maxCount = Math.max(thisCount, maxCount);", "  }", "  for (int j = 0; j < counts.length; j++) {", "    if (counts[j][1] == maxCount) {", "        modes.add(counts[j][0]);", "    }", "  }", "  return modes;",
                "}"]);
            b = b + "(" + a + ")";
            break;
        case "STD_DEV":
            Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
            b = Blockly.cpp.provideFunction_("math_standard_deviation", ["num " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List myList) {", "  // First filter list for numbers only.", "  List numbers = new List.from(myList);", "  numbers.removeWhere((a) => a is! num);", "  if (numbers.isEmpty) return null;", "  num n = numbers.length;", "  num sum = 0;", "  numbers.forEach((x) => sum += x);", "  num mean = sum / n;",
                "  num sumSquare = 0;", "  numbers.forEach((x) => sumSquare += Math.pow(x - mean, 2));", "  return Math.sqrt(sumSquare / n);", "}"]);
            b = b + "(" + a + ")";
            break;
        case "RANDOM":
            Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
            b = Blockly.cpp.provideFunction_("math_random_item", ["dynamic " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(List myList) {", "  int x = new Math.Random().nextInt(myList.length);", "  return myList[x];", "}"]);
            b = b + "(" + a + ")";
            break;
        default:
            throw Error("Unknown operator: " +
                b);
    }
    return [b, Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.math_modulo = function (a) {
    var b = Blockly.cpp.valueToCode(a, "DIVIDEND", Blockly.cpp.ORDER_MULTIPLICATIVE) || "0";
    a = Blockly.cpp.valueToCode(a, "DIVISOR", Blockly.cpp.ORDER_MULTIPLICATIVE) || "0";
    return [b + " % " + a, Blockly.cpp.ORDER_MULTIPLICATIVE]
};
Blockly.cpp.math_constrain = function (a) {
    Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
    var b = Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_NONE) || "0",
        c = Blockly.cpp.valueToCode(a, "LOW", Blockly.cpp.ORDER_NONE) || "0";
    a = Blockly.cpp.valueToCode(a, "HIGH", Blockly.cpp.ORDER_NONE) || "double.INFINITY";
    return ["Math.min(Math.max(" + b + ", " + c + "), " + a + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.math_random_int = function (a) {
    Blockly.cpp.definitions_.import_cpp_rand = "#include<cstdlib>";
    a = Blockly.cpp.valueToCode(a, "TO", Blockly.cpp.ORDER_NONE) || "0";
    return ["rand() % " + a, Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.math_random_float = function (a) {
    Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;";
    return ["new Math.Random().nextDouble()", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.procedures = {};
Blockly.cpp.procedures_defreturn = function (a) {
    var b = Blockly.cpp.nameDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME), c = ""; Blockly.cpp.STATEMENT_PREFIX && (c += Blockly.cpp.injectId(Blockly.cpp.STATEMENT_PREFIX, a)); Blockly.cpp.STATEMENT_SUFFIX && (c += Blockly.cpp.injectId(Blockly.cpp.STATEMENT_SUFFIX, a)); c && (c = Blockly.cpp.prefixLines(c, Blockly.cpp.INDENT)); var d = ""; Blockly.cpp.INFINITE_LOOP_TRAP && (d = Blockly.cpp.prefixLines(Blockly.cpp.injectId(Blockly.cpp.INFINITE_LOOP_TRAP, a),
        Blockly.cpp.INDENT)); var e = Blockly.cpp.statementToCode(a, "STACK"), f = Blockly.cpp.valueToCode(a, "RETURN", Blockly.cpp.ORDER_NONE) || "", g = ""; e && f && (g = c); f && (f = Blockly.cpp.INDENT + "return " + f + ";\n"); for (var m = f ? "dynamic" : "void", k = [], l = a.getVars(), h = 0; h < l.length; h++)k[h] = Blockly.cpp.nameDB_.getName(l[h], Blockly.VARIABLE_CATEGORY_NAME); c = m + " " + b + "(" + k.join(", ") + ") {\n" + c + d + e + g + f + "}"; c = Blockly.cpp.scrub_(a, c); Blockly.cpp.definitions_["%" + b] = c; return null
}; Blockly.cpp.procedures_defnoreturn = Blockly.cpp.procedures_defreturn;

Blockly.cpp.procedures_defnoreturn = Blockly.cpp.procedures_defreturn;
Blockly.cpp.procedures_callreturn = function (a) {
    for (var b = Blockly.cpp.nameDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.cpp.valueToCode(a, "ARG" + d, Blockly.cpp.ORDER_NONE) || "null";
    return [b + "(" + c.join(", ") + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.procedures_callnoreturn = function (a) {
    for (var b = Blockly.cpp.nameDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.cpp.valueToCode(a, "ARG" + d, Blockly.cpp.ORDER_NONE) || "null";
    return b + "(" + c.join(", ") + ");\n"
};
Blockly.cpp.procedures_ifreturn = function (a) {
    var b = "if (" + (Blockly.cpp.valueToCode(a, "CONDITION", Blockly.cpp.ORDER_NONE) || "false") + ") {\n";
    a.hasReturnValue_ ? (a = Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_NONE) || "null", b += Blockly.cpp.INDENT + "return " + a + ";\n") : b += Blockly.cpp.INDENT + "return;\n";
    return b + "}\n"
};
Blockly.cpp.texts = {};
Blockly.cpp.addReservedWords("Html,Math");
Blockly.cpp.text = function (a) {
    return [Blockly.cpp.quote_(a.getFieldValue("TEXT")), Blockly.cpp.ORDER_ATOMIC]
};
Blockly.cpp.text_join = function (a) {
    switch (a.itemCount_) {
        case 0:
            return ["''", Blockly.cpp.ORDER_ATOMIC];
        case 1:
            return [(Blockly.cpp.valueToCode(a, "ADD0", Blockly.cpp.ORDER_UNARY_POSTFIX) || "''") + ".toString()", Blockly.cpp.ORDER_UNARY_POSTFIX];
        default:
            for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) b[c] = Blockly.cpp.valueToCode(a, "ADD" + c, Blockly.cpp.ORDER_NONE) || "''";
            a = "[" + b.join(",") + "].join()";
            return [a, Blockly.cpp.ORDER_UNARY_POSTFIX]
    }
};
Blockly.cpp.text_append = function (a) {
    var b = Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_UNARY_POSTFIX);
    a = Blockly.cpp.valueToCode(a, "TEXT", Blockly.cpp.ORDER_NONE) || "''";
    return b + "+" + "=" + a + ";\n"
};
Blockly.cpp.text_length = function (a) {
    return [Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_UNARY_POSTFIX) + ".length()", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_isEmpty = function (a) {
    return [Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_UNARY_POSTFIX) + ".empty()", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_indexOf = function (a) {
    var b = "FIRST" == a.getFieldValue("END") ? "find" : "lastfind",
        c = Blockly.cpp.valueToCode(a, "FIND", Blockly.cpp.ORDER_NONE) || "''";
    b = (Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_UNARY_POSTFIX) || "''") + "." + b + "(" + c + ")";
    return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.cpp.ORDER_ADDITIVE] : [b, Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_charAt = function (a) {
    var b = a.getFieldValue("WHERE") || "FROM_START",
        c = Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_UNARY_POSTFIX) || "''";
    switch (b) {
        case "FIRST":
            return [c + "[0]", Blockly.cpp.ORDER_UNARY_POSTFIX];
        case "FROM_START":
            return a = Blockly.cpp.getAdjusted(a, "AT"), [c + "[" + a + "]", Blockly.cpp.ORDER_UNARY_POSTFIX];
        case "LAST":
        case "FROM_END":
            return a = Blockly.cpp.getAdjusted(a, "AT", 1), b = Blockly.cpp.provideFunction_("text_get_from_end", ["String " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ +
                "(String text, num x) {", "  return text[text.length - x];", "}"]), [b + "(" + c + ", " + a + ")", Blockly.cpp.ORDER_UNARY_POSTFIX];
        case "RANDOM":
            return Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;", b = Blockly.cpp.provideFunction_("text_random_letter", ["String " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(String text) {", "  int x = new Math.Random().nextInt(text.length);", "  return text[x];", "}"]), [b + "(" + c + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
    }
    throw Error("Unhandled option (text_charAt).");
};
Blockly.cpp.text_getSubstring = function (a) {
    var b = Blockly.cpp.valueToCode(a, "STRING", Blockly.cpp.ORDER_UNARY_POSTFIX) || "''",
        c = a.getFieldValue("WHERE1"), d = a.getFieldValue("WHERE2");
    if ("FIRST" == c && "LAST" == d) a = b; else if (b.match(/^'?\w+'?$/) || "FROM_END" != c && "FROM_START" == d) {
        switch (c) {
            case "FROM_START":
                var e = Blockly.cpp.getAdjusted(a, "AT1");
                break;
            case "FROM_END":
                e = Blockly.cpp.getAdjusted(a, "AT1", 1, !1, Blockly.cpp.ORDER_ADDITIVE);
                e = b + ".length - " + e;
                break;
            case "FIRST":
                e = "0";
                break;
            default:
                throw Error("Unhandled option (text_getSubstring).");
        }
        switch (d) {
            case "FROM_START":
                var f =
                    Blockly.cpp.getAdjusted(a, "AT2", 1);
                break;
            case "FROM_END":
                f = Blockly.cpp.getAdjusted(a, "AT2", 0, !1, Blockly.cpp.ORDER_ADDITIVE);
                f = b + ".length - " + f;
                break;
            case "LAST":
                break;
            default:
                throw Error("Unhandled option (text_getSubstring).");
        }
        a = "LAST" == d ? b + ".substr(" + e + ")" : b + ".substr(" + e + ", " + f + ")"
    } else e = Blockly.cpp.getAdjusted(a, "AT1"), f = Blockly.cpp.getAdjusted(a, "AT2"), a = Blockly.cpp.provideFunction_("text_get_substring", ["List " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(text, where1, at1, where2, at2) {",
        "  int getAt(where, at) {", "    if (where == 'FROM_END') {", "      at = text.length - 1 - at;", "    } else if (where == 'FIRST') {", "      at = 0;", "    } else if (where == 'LAST') {", "      at = text.length - 1;", "    } else if (where != 'FROM_START') {", "      throw 'Unhandled option (text_getSubstring).';", "    }", "    return at;", "  }", "  at1 = getAt(where1, at1);", "  at2 = getAt(where2, at2) + 1;", "  return text.substring(at1, at2);", "}"]) + "(" + b + ", '" + c + "', " + e + ", '" + d + "', " + f + ")";
    return [a, Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_changeCase = function (a) {
    var b = { UPPERCASE: ".toUpperCase()", LOWERCASE: ".toLowerCase()", TITLECASE: null }[a.getFieldValue("CASE")];
    a = Blockly.cpp.valueToCode(a, "TEXT", b ? Blockly.cpp.ORDER_UNARY_POSTFIX : Blockly.cpp.ORDER_NONE) || "''";
    return [b ? a + b : Blockly.cpp.provideFunction_("text_toTitleCase", ["String " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(String str) {", "  RegExp exp = new RegExp(r'\\b');", "  List<String> list = str.split(exp);", "  final title = new StringBuffer();", "  for (String part in list) {",
        "    if (part.length > 0) {", "      title.write(part[0].toUpperCase());", "      if (part.length > 0) {", "        title.write(part.substring(1).toLowerCase());", "      }", "    }", "  }", "  return title.toString();", "}"]) + "(" + a + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_trim = function (a) {
    var b = {
        LEFT: ".replaceFirst(new RegExp(r'^\\s+'), '')",
        RIGHT: ".replaceFirst(new RegExp(r'\\s+$'), '')",
        BOTH: ".trim()"
    }[a.getFieldValue("MODE")];
    return [(Blockly.cpp.valueToCode(a, "TEXT", Blockly.cpp.ORDER_UNARY_POSTFIX) || "''") + b, Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_print = function (a) {
    //判断是否需要换行
    var b = {
        ENDL: "<<endl;\n",
        NODL: ";\n"
    }[a.getFieldValue("OP")];

    return "cout<<" + (Blockly.cpp.valueToCode(a, "TEXT", Blockly.cpp.ORDER_NONE)) + b;
};
Blockly.cpp.text_input = function (a) {
    var variable_name = Blockly.cpp.valueToCode(a, "TEXT", Blockly.cpp.ORDER_NONE);
    return "cin>>" + variable_name + ";\n";
}
Blockly.cpp.text_prompt_ext = function (a) {
    Blockly.cpp.definitions_.import_cpp_html = "import 'cpp:html' as Html;";
    var b = "Html.window.prompt(" + (a.getField("TEXT") ? Blockly.cpp.quote_(a.getFieldValue("TEXT")) : Blockly.cpp.valueToCode(a, "TEXT", Blockly.cpp.ORDER_NONE) || "''") + ", '')";
    "NUMBER" == a.getFieldValue("TYPE") && (Blockly.cpp.definitions_.import_cpp_math = "import 'cpp:math' as Math;", b = "Math.parseDouble(" + b + ")");
    return [b, Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_prompt = Blockly.cpp.text_prompt_ext;
Blockly.cpp.text_count = function (a) {
    var b = Blockly.cpp.valueToCode(a, "TEXT", Blockly.cpp.ORDER_UNARY_POSTFIX) || "''";
    a = Blockly.cpp.valueToCode(a, "SUB", Blockly.cpp.ORDER_NONE) || "''";
    return [Blockly.cpp.provideFunction_("text_count", ["int " + Blockly.cpp.FUNCTION_NAME_PLACEHOLDER_ + "(String haystack, String needle) {", "  if (needle.length == 0) {", "    return haystack.length + 1;", "  }", "  int index = 0;", "  int count = 0;", "  while (index != -1) {", "    index = haystack.indexOf(needle, index);", "    if (index != -1) {",
        "      count++;", "     index += needle.length;", "    }", "  }", "  return count;", "}"]) + "(" + b + ", " + a + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_replace = function (a) {
    var b = Blockly.cpp.valueToCode(a, "TEXT", Blockly.cpp.ORDER_UNARY_POSTFIX) || "''",
        c = Blockly.cpp.valueToCode(a, "FROM", Blockly.cpp.ORDER_NONE) || "''";
    a = Blockly.cpp.valueToCode(a, "TO", Blockly.cpp.ORDER_NONE) || "''";
    return [b + ".replaceAll(" + c + ", " + a + ")", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.text_reverse = function (a) {
    return ["new String.fromCharCodes(" + (Blockly.cpp.valueToCode(a, "TEXT", Blockly.cpp.ORDER_UNARY_POSTFIX) || "''") + ".runes.toList().reversed)", Blockly.cpp.ORDER_UNARY_POSTFIX]
};
Blockly.cpp.variables = {};
Blockly.cpp.variables_get = function (a) {
    return [Blockly.cpp.nameDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE), Blockly.cpp.ORDER_ATOMIC]
};
Blockly.cpp.variables_set = function (a) {
    var b = Blockly.cpp.valueToCode(a, "VALUE", Blockly.cpp.ORDER_ASSIGNMENT) || "0";
    return Blockly.cpp.nameDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE) + " = " + b + ";\n"
};
Blockly.cpp.variablesDynamic = {};
Blockly.cpp.variables_get_dynamic = Blockly.cpp.variables_get;
Blockly.cpp.variables_set_dynamic = Blockly.cpp.variables_set;